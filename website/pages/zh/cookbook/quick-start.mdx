---
title: 快速开始
---

本指南将快速带您了解如何初始化、创建子图，并将其部署到子图工作室或[托管服务](#hosted-service)。

确保您的子图将索引来自[支持的网络](/developing/supported-networks)的数据。

## 子图工作室

### 1. 安装 Graph CLI

Graph CLI 是用 JavaScript 编写的，需要安装`npm` 或`yarn` 来使用。

```sh
# NPM
$ npm install -g @graphprotocol/graph-cli

# Yarn
$ yarn global add @graphprotocol/graph-cli
```

### 2. 初始化子图

- 从现有合约初始化子图。

```sh
graph init --studio <SUBGRAPH_SLUG>
```

- 子图 slug 是子图的一个标识符。CLI 工具将引导你完成创建子图的步骤，如合约地址、网络等，你可以在下面的截图中看到。

![子图命令](/img/Subgraph-Slug.png)

> 提示: 考虑增加 `--index-events` 到上面的命令行中以节省时间。它用模式中的实体和每个触发事件的映射引导子图。它使用模式中的实体和每个发出事件的简单映射引导子图。

### 3. 编写子图

前面的命令创建了一个原始子图，可以将其用作构建子图的起点。当对子图进行更改时，将主要使用三个文件:

- 清单（subgraph.yaml）--清单定义子图将索引哪些数据源。
- 模式（schema.graphql）--GraphQL 模式定义从子图中检索到的数据。
- AssemblyScript 映射（mapping.ts）--将数据源中的数据转换为模式中定义的实体的代码。

关于如何编写子图的更多信息，请参见 [创建子图](/developing/creating-a-subgraph)

### 4. 部署到子图工作室

- 进入子图工作室 [https://thegraph.com/studio/](https://thegraph.com/studio/) 并连接钱包。
- 点击 "创建 "并输入在第 2 步使用的子图 slug。
- 在子图文件夹下运行这些命令。

```sh
$ graph codegen
$ graph build
```

- 认证并部署子图。部署密钥可以在子图工作室的子图页面上找到。

```sh
$ graph auth --studio <DEPLOY_KEY>
$ graph deploy --studio <SUBGRAPH_SLUG>
```

- 你会被要求提供一个版本标签。强烈建议使用以下惯例来命名版本。例如：`0.0.1`, `v1`, `version1`

### 5. 检查日志

日志应该告诉你是否有任何错误。如果子图失败了，你可以通过使用 [GraphiQL Playground](https://graphiql-online.com/)查询子图的健康状况。使用[这个端点](https://api.thegraph.com/index-node/graphql)。注意，你可以利用下面的查询，输入你的子图的部署 ID。在这种情况下，`Qm...` 是部署 ID（可以在子图页面的**详细信息**下找到）。下面的查询会提示，当一个子图失败时，则可进行相应调试。

```sh
{
  indexingStatuses(subgraphs: ["Qm..."]) {
    node
    synced
    health
    fatalError {
      message
      block {
        number
        hash
      }
      handler
    }
    nonFatalErrors {
      message
      block {
        number
        hash
      }
      handler
    }
    chains {
      network
      chainHeadBlock {
        number
      }
      earliestBlock {
        number
      }
      latestBlock {
        number
      }
      lastHealthyBlock {
        number
      }
    }
    entityCount
  }
}
```

### 6. 查询子图

You can now query your subgraph by following [these instructions](/querying/querying-the-graph). You can query from your dApp if you don't have your API key via the free, rate-limited temporary query URL that can be used for development and staging. You can read the additional instructions for how to query a subgraph from a frontend application [here](/querying/querying-from-an-application).

## 托管服务

### 1. 安装 Graph CLI

"Graph CLI 是一个 npm 包，你需要安装 `npm`或 `yarn`来使用。

```sh
# NPM
$ npm install -g @graphprotocol/graph-cli

# Yarn
$ yarn global add @graphprotocol/graph-cli
```

### 2. 初始化子图

- 从现有合约初始化子图。

```sh
$ graph init --product hosted-service --from-contract <Address>
```

- 你需要提供一个子图的名称。其格式为 `<Github>/<Subgraph Name>`. 例如: `graphprotocol/examplesubgraph`

- 如果想从一个实例初始化，请运行下面的命令。

```sh
$ graph init --product hosted-service --from-example
```

- 在这个例子中，子图基于 Dani Grant 的 Gravity 合约，该合约管理用户的头像，并在头像创建或更新时发出`NewGravatar`或`UpdateGravatar`事件。

### 3. 编写子图

前面的命令将创建子图基础，可以在这个基础上建立子图。在对子图进行修改时，将主要处理三个文件。

- 清单（subgraph.yaml）--该清单定义子图将索引哪些数据源。
- 模式（schema.graphql）--GraphQL 模式定义从子图中检索到的数据。
- AssemblyScript 映射（mapping.ts）--将数据源中的数据转换为模式中定义的实体的代码。

关于如何编写子图的更多信息，请参见 [创建子图](/developing/creating-a-subgraph)

### 4. 部署子图

- 使用你的 github 账户登录 [托管服务](https://thegraph.com/hosted-service/)。
- 点击添加子图，并填写所需信息。使用和第 2 步中相同的子图名称。
- 在子图文件夹中运行 `codegen`。

```sh
 # NPM
$ npm run codegen

# Yarn
$ yarn codegen
```

- 添加你的访问令牌并部署你的子图。访问令牌可以在你的仪表板上的托管服务中找到。

```sh
$ graph auth --product hosted-service <ACCESS_TOKEN>
$ graph deploy --product hosted-service <GITHUB_USER>/<SUBGRAPH NAME>
```

### 5. 检查日志

日志会告诉是否有任何错误。如果子图失败了，可以通过使用 [GraphiQL Playground](https://graphiql-online.com/)查询子图的健康状况。使用[这个端点](https://api.thegraph.com/index-node/graphql)。注意，你可以利用下面的查询，输入你的子图的部署 ID。在这种情况下，`Qm...` 是部署 ID（可以在子图页面的**详细信息**下找到）。下面的查询会提示，当一个子图失败时，则可进行相应调试。

```sh
{
  indexingStatuses(subgraphs: ["Qm..."]) {
    node
    synced
    health
    fatalError {
      message
      block {
        number
        hash
      }
      handler
    }
    nonFatalErrors {
      message
      block {
        number
        hash
      }
      handler
    }
    chains {
      network
      chainHeadBlock {
        number
      }
      earliestBlock {
        number
      }
      latestBlock {
        number
      }
      lastHealthyBlock {
        number
      }
    }
    entityCount
  }
}
```

### 6. 查询子图

按照 [这些说明](/querying/querying-the-hosted-service)，在托管服务上查询子图。
