---
title: Замените контракт и сохраните его историю с помощью графтинга (переноса)
---

В этом руководстве вы узнаете, как создавать и развертывать новые субграфы путем графтинга (переноса) существующих субграфов.

## Что такое графтинг (перенос)?

При графтинге (переносе) повторно используются данные из существующего субрафа и начинается их индексация в более позднем блоке. Это может быть полезно в период разработки, чтобы быстро устранить простые ошибки в мэппинге или временно восстановить работу существующего субграфа после его сбоя. Кроме того, его можно использовать при добавлении в субграф функции, индексация которой с нуля занимает много времени.

Перенесённый субграф может использовать схему GraphQL, которая не идентична схеме базового субграфа, а просто совместима с ней. Это должна быть автономно действующая схема субграфа, но она может отличаться от схемы базового субграфа следующим образом:

- Она добавляет или удаляет типы элементов
- Она удаляет атрибуты из типов элементов
- Она добавляет обнуляемые атрибуты к типам элементов
- Она превращает необнуляемые атрибуты в обнуляемые
- Она добавляет значения в перечисления
- Она добавляет или удаляет интерфейсы
- Она изменяется в зависимости от того, под какой тип элементов реализован интерфейс

Для получения дополнительной информации вы можете перейти:

- [Графтинг (перенос)](https://thegraph.com/docs/en/developing/creating-a-subgraph#grafting-onto-existing-subgraphs)

В этом руководстве мы рассмотрим базовый вариант использования. Мы заменим существующий договор на идентичный договор (с новым адресом, но тем же кодом). Затем привяжем существующий субграф к «базовому» субграфу, который отслеживает новый контракт.

## Создание существующего субграфа

Создание субграфов — важная часть The Graph, более подробно описанная [здесь](http://localhost:3000/en/cookbook/quick-start/). Чтобы иметь возможность создавать и развертывать существующий субграф, используемый в этом руководстве, предоставляется следующее репо:

- [Пример репо субграфа](https://github.com/t-proctor/grafting-tutorial)

> Примечание: контракт, использованный в субграфе, был взят из следующего [Hackathon Starterkit](https://github.com/schmidsi/hackathon-starterkit).

## Определение манифеста субграфа

Манифест субграфа `subgraph.yaml` определяет источники данных для субграфа, релевантные триггеры и функции, которые должны выполняться в ответ на эти триггеры. Ниже приведен пример манифеста субграфа, который вы будете использовать:

```yaml
specVersion: 0.0.4
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum
    name: Lock
    network: goerli
    source:
      address: '0x4Ed995e775D3629b0566D2279f058729Ae6EA493'
      abi: Lock
      startBlock: 7674603
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Withdrawal
      abis:
        - name: Lock
          file: ./abis/Lock.json
      eventHandlers:
        - event: Withdrawal(uint256,uint256)
          handler: handleWithdrawal
      file: ./src/lock.ts
```

- Источник данных `Lock` — это abi и адрес контракта, которые мы получим при компиляции и развертывании контракта
- Сеть должна соответствовать запрашиваемой индексированной сети. Поскольку мы работаем в тестовой сети Goerli, это сеть `goerli`
- Раздел `mapping` определяет интересующие нас триггеры и функции, которые должны запускаться в ответ на эти триггеры. В этом случае мы уделяем внимание событию `Withdrawal` и вызываем функцию `handleWithdrawal` при его возникновении.

## Определение манифеста графтинга (переноса)

Графтинг требует добавления двух новых элементов в исходный манифест субграфа:

```yaml
---
features:
  - grafting # feature name
graft:
  base: Qm... # subgraph ID of base subgraph
  block: 1502122 # block number
```

- `features:` — это список всех используемых [названий функций](developing/creating-a-subgraph/#experimental-features).
- `graft:` — это карта субграфа `base` и блока, к которому применяется графтинг (перенос). `block` — это номер блока, с которого начинается индексация. The Graph скопирует данные базового субграфа до указанного блока включительно, а затем продолжит индексацию нового субграфа, начиная с этого блока.

Значения `base` и `block` можно найти, развернув два субграфа: один для базовой индексации, а другой с графтингом (переносом)

## Развертывание базового субграфа

1. Перейдите в [пользовательский интерфейс The Graph Studio](https://thegraph.com/studio/) и создайте субграф в тестовой сети Goerli с именем `graft-example`
2. Следуйте инструкциям в `AUTH & DEPLOY` на странице субграфа в `graft-example` из репо
3. После завершения убедитесь, что субграф правильно индексируется. Если вы запустите следующую команду в The Graph Playground

```graphql
{
  withdrawals(first: 5) {
    id
    amount
    when
  }
}
```

Отклик будет подобным этому:

```
{
  "data": {
    "withdrawals": [
      {
        "id": "0x13098b538a61837e9f29b32fb40527bbbe63c9120c250242b02b69bb42c287e5-5",
        "amount": "0",
        "when": "1664367528"
      },
      {
        "id": "0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498-3",
        "amount": "0",
        "when": "1664367648"
      }
    ]
  }
}
```

После того как Вы убедились, что субграф индексируется правильно, Вы можете быстро обновить субграф с помощью графтинга (переноса).

## Развертывание графтинга (переноса) субграфа

Замененный subgraph.yaml будет иметь новый адрес контракта. Это может произойти, когда вы обновляете свое децентрализованное приложение, повторно развертываете контракт и т. д.

1. Перейдите в [пользовательский интерфейс The Graph Studio](https://thegraph.com/studio/) и создайте субграф в тестовой сети Goerli с именем `graft-replacement`
2. Создайте новый манифест. `subgraph.yaml` для `graph-replacement` содержит другой адрес контракта и новую информацию о том, как его следует переносить. Это `блок` [последнего события, созданного](https://goerli.etherscan.io/tx/0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498) старым контрактом и `base` старого субграфа. Идентификатор субграфа `base` — это `ID развертывания` исходного субграфа `graph-example`. Вы можете найти эту информацию в пользовательском интерфейсе The Graph Studio.
3. Следуйте инструкциям в `AUTH & DEPLOY` на странице субграфа в `graft-replacement` из репо
4. После завершения убедитесь, что субграф правильно индексируется. Если вы запустите следующую команду в The Graph Playground

```graphql
{
  withdrawals(first: 5) {
    id
    amount
    when
  }
}
```

Это должно привести к следующему результату:

```
{
  "data": {
    "withdrawals": [
      {
        "id": "0x13098b538a61837e9f29b32fb40527bbbe63c9120c250242b02b69bb42c287e5-5",
        "amount": "0",
        "when": "1664367528"
      },
      {
        "id": "0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498-3",
        "amount": "0",
        "when": "1664367648"
      },
      {
        "id": "0xb4010e4c76f86762beb997a13cf020231778eaf7c64fa3b7794971a5e6b343d3-22",
        "amount": "0",
        "when": "1664371512"
      }
    ]
  }
}
```

Вы можете видеть, что субграф `graft-replacement` индексируется из старых данных `graph-example` и более новых данных из нового адреса контракта. Исходный контракт генерировал два события `Withdrawal`: [Событие 1](https://goerli.etherscan.io/tx/0x800c92fcc0edbd26f74e19ad058c62008a47c7789f2064023b987028343dd498) и [Событие 2](https:/ /goerli.etherscan.io/address/0x4ed995e775d3629b0566d2279f058729ae6ea493). Новый контракт выдал один `Withdrawal` после [События 3](https://goerli.etherscan.io/tx/0xb4010e4c76f86762beb997a13cf020231778eaf7c64fa3b7794971a5e6b343d3). Две ранее проиндексированные транзакции (События 1 и 2) и новая транзакция (Событие 3) были объединены в субграфе `graft-replacement`.

Поздравляем! Вы успешно перенесли один субграф в другой.

## Дополнительные ресурсы

Если Вы хотите получить больше опыта в графтинге (переносе), вот несколько примеров популярных контрактов:

- [Траектория](https://github.com/messari/subgraphs/blob/master/subgraphs/curve-finance/protocols/curve-finance/templates/curve.template.yaml)
- [ERC-721](https://github.com/messari/subgraphs/blob/master/subgraphs/erc721-metadata/subgraph.yaml)
- [Uniswap](https://github.com/messari/subgraphs/blob/master/subgraphs/uniswap-v3/protocols/uniswap-v3/config/templates/uniswap.v3.template.yaml),

Чтобы стать еще большим экспертом по Graph, рассмотрите возможность узнать о других способах обработки изменений в базовых источниках данных. Такие альтернативы, как [шаблоны источников данных](developing/creating-a-subgraph/#data-source-templates), могут дать аналогичные результаты

> Примечание: многие материалы этой статьи были взяты из ранее опубликованной [статьи Arweave](/cookbook/arweave/)
